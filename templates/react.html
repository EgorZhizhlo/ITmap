{% extends 'base.html' %}
{% block title %}
<div class="container text-center">
  <div class="semi-circle">
    <h1>React</h1>
  </div>
</div>
{% endblock title %}
{% block hero %}
    <img src="/static/images/flower.webp" alt="Слева" class="side-fixed left visible" />
    <img src="/static/images/flower.webp" alt="Справа" class="side-fixed right visible" />
{% endblock hero %}
{% block content %}
<link rel="stylesheet" href="/static/css/react.css"/>
<main id="infographic" class="d-flex flex-column align-items-center py-5">
    <!-- Секция Основа -->
    <section class="step one text-danger">
        <div class="circle">
            <h2>Основа</h2>
        </div>
        <article data-step="1">
            <header class="d-flex align-items-center bg-danger bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal" data-modal-content="React — это популярная JavaScript-библиотека (разработанная и поддерживаемая Facebook) для построения пользовательских интерфейсов. Основные её особенности:

        Компонентный подход
        Интерфейс разбивается на небольшие, независимые и переиспользуемые «компоненты» — функции или классы, возвращающие разметку. Каждый компонент содержит свою логику, состояние и шаблон, что упрощает разработку и поддержку больших приложений.
        
        JSX
        Специальный синтаксис, позволяющий писать разметку (HTML-подобный код) прямо внутри JavaScript-файлов. JSX компилируется в чистые вызовы React.createElement, но делает код более читаемым и декларативным.
        
        Virtual DOM
        Вместо прямого изменения реального DOM React сначала создаёт виртуальное представление дерева элементов в памяти. При обновлении состояния компонента React сравнивает старое и новое виртуальные дерево (диффинг) и вносит минимальный набор изменений в реальный DOM. Это повышает производительность и снижает лишние перерисовки.
        
        Однонаправленный поток данных
        Данные в React передаются «вниз» по иерархии компонентов через свойства (props). Компоненты могут хранить локальное состояние (state), а при изменении этого состояния React автоматически обновляет интерфейс. Такой подход упрощает отслеживание, откуда пришли данные и как они изменились.
        
        Хуки (Hooks)
        Начиная с версии 16.8, React ввёл «хуки» — функции вроде useState, useEffect и др., которые позволяют работать с состоянием и побочными эффектами внутри функциональных компонентов, не переходя к классам.
        
        Экосистема и инструменты
        Вокруг React сформировалась огромная экосистема: роутеры (React Router), системы управления состоянием (Redux, MobX, Context API), UI-библиотеки (Material-UI, Ant Design), инструменты сборки (Create React App, Vite), тестирования (Jest, React Testing Library) и многое другое.
        ">
                    <i class="fa-solid fa-meteor bg-danger"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">Что такое React?</h6>
            </header>
        </article>
        <article data-step="2">
            <header class="d-flex align-items-center text-danger bg-danger bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal"
                    data-modal-content="Vite — это инструмент для сборки, который позволяет ускорить и упростить разработку современных веб-проектов">
                    <i class="fa-solid fa-meteor bg-danger"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">Инструмент</h6>
            </header>
        </article>
    </section>

    <!-- Секция Компоненты
-->
    <section class="step two text-warning">
        <div class="circle">
            <h2>Компоненты
            </h2>
        </div>
        <article data-step="3">
            <header class="d-flex align-items-center text-danger bg-danger bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal" data-modal-content="Функциональные компоненты — это одни из наиболее распространённых компонентов, с которыми вы столкнётесь при работе с React. Это просто функции JavaScript. Мы можем создать функциональный компонент для React, написав функцию JavaScript. Эти функции могут получать или не получать данные в качестве параметров. В функциональных компонентах возвращаемое значение — это код JSX для отображения в дереве DOM. Функциональные компоненты также могут иметь состояние, которое управляется с помощью хуков React.
        ">
                    <i class="fa-solid fa-meteor bg-danger"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">Функциональные Компоненты
                </h6>
            </header>
        </article>
        <article data-step="4">
            <header class="d-flex align-items-center text-danger bg-danger bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal"
                    data-modal-content="JSX расшифровывается как JavaScript XML. Он позволяет писать HTML на JavaScript и преобразовывать HTML-теги в элементы React.">
                    <i class="fa-solid fa-meteor bg-danger"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">JSX</h6>
            </header>
        </article>
        <article data-step="5">
            <header class="d-flex align-items-center text-danger bg-danger bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal" data-modal-content="Проп (сокращение от «свойства») и состояние — это обычные объекты JavaScript. Хотя и то, и другое содержит информацию, которая влияет на вывод компонента, они отличаются одним важным аспектом: проп передаётся компоненту (аналогично параметрам функции), а состоянием управляет компонент (аналогично переменным, объявленным внутри функции).
        ">
                    <i class="fa-solid fa-meteor bg-danger"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">Props против State</h6>
            </header>
        </article>
        <article data-step="6">
            <header class="d-flex align-items-center text-warning bg-warning bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal"
                    data-modal-content="В React вы можете создавать отдельные компоненты, которые инкапсулируют необходимое вам поведение. Затем вы можете отображать только некоторые из них в зависимости от состояния вашего приложения.

        Условный рендеринг в React работает так же, как условия в JavaScript. Используйте операторы JavaScript, такие как if или условный оператор, чтобы создавать элементы, представляющие текущее состояние, и позволяйте React обновлять пользовательский интерфейс в соответствии с ними.">
                    <i class="fa-solid fa-cookie-bite bg-warning"></i>
                </span>
                <h6 class="text-uppercase my-3 pe-4">Условный Рендеринг
                </h6>
            </header>
        </article>
        <article data-step="7">
            <header class="d-flex align-items-center text-warning bg-warning bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal" data-modal-content="В React есть мощная модель композиции, и рекомендуется использовать композицию вместо наследования для повторного использования кода между компонентами.
        ">
                    <i class="fa-solid fa-cookie-bite bg-warning"></i>
                </span>
                <h6 class="text-uppercase my-3 pe-4">Композиция против наследования
                </h6>
            </header>
        </article>
    </section>

    <!-- Секция Рендеринг -->
    <section class="step three text-success">
        <div class="circle">
            <h2>Рендеринг</h2>
        </div>
        <article data-step="8">
            <header class="d-flex align-items-center text-warning bg-warning bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal"
                    data-modal-content="React использует декларативный подход к рендерингу компонентов, что означает, что разработчики указывают, как должен выглядеть компонент, а React заботится о его рендеринге на экране. Это отличается от императивного подхода, при котором разработчики пишут код для ручного управления DOM (объектной моделью документа) для обновления пользовательского интерфейса.

        Виртуальный DOM (VDOM) — важный аспект работы React. Это облегчённое представление DOM (модели документа) в памяти, которое используется для оптимизации рендеринга компонентов в приложении React.
        
        Компоненты записываются в виде классов или функций JavaScript, которые определяют метод рендеринга. Метод рендеринга возвращает описание того, как должен выглядеть компонент, с использованием синтаксиса JSX.
        При рендеринге компонента React создаёт виртуальное представление DOM (VDOM) этого компонента. VDOM — это упрощённое представление DOM в памяти, которое используется для оптимизации рендеринга компонентов.
        React сравнивает представление компонента в VDOM с предыдущим представлением в VDOM (если оно существует). Если между двумя представлениями в VDOM есть различия, React вычисляет минимальное количество обновлений DOM, необходимых для приведения фактического DOM в соответствие с новым VDOM.
        React обновляет фактический DOM с минимальным количеством обновлений DOM, необходимых для отражения изменений в VDOM.
        Этот процесс известен как согласование и является важным аспектом работы React. Используя декларативный подход и VDOM, React может оптимизировать рендеринг компонентов и повысить производительность веб-приложений.">
                    <i class="fa-solid fa-cookie-bite bg-warning"></i>
                </span>
                <h6 class="text-uppercase my-3 pe-4">Что это?</h6>
            </header>
        </article>
        <article data-step="9">
            <header class="d-flex align-items-center text-warning bg-warning bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal" data-modal-content="Компоненты React имеют жизненный цикл, состоящий из трёх этапов: монтирование, обновление и демонтаж, а также несколько «методов жизненного цикла», которые можно переопределить для запуска кода в определённые моменты процесса.

        Не рекомендуется использовать методы жизненного цикла вручную. Вместо этого используйте хук useEffect с функциональными компонентами.
        ">
                    <i class="fa-solid fa-cookie-bite bg-warning"></i>
                </span>
                <h6 class="text-uppercase my-3 pe-4">Жизненный цикл компонента
                </h6>
            </header>
        </article>
        <article data-step="10">
            <header class="d-flex align-items-center text-warning bg-warning bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal" data-modal-content="При отображении списков в React вы можете использовать свойство key для указания уникального ключа для каждого элемента. Этот ключ используется для определения элемента, который нужно обновить, если вы хотите обновить конкретный элемент.
        ">
                    <i class="fa-solid fa-cookie-bite bg-warning"></i>
                </span>
                <h6 class="text-uppercase my-3 pe-4">Списки и ключи
                </h6>
            </header>
        </article>
        <article data-step="11">
            <header class="d-flex align-items-center text-success bg-success bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal" data-modal-content="Термин «рендеринг свойств» относится к методу совместного использования кода между компонентами React с помощью свойства, значением которого является функция.

        Компонент с опорой render принимает функцию, которая возвращает элемент React, и вызывает её вместо реализации собственной логики рендеринга.          
        ">
                    <i class="fa-solid fa-ghost bg-success px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">Рендеринг Реквизита
                </h6>
            </header>
        </article>
        <article data-step="12">
            <header class="d-flex align-items-center text-success bg-success bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal" data-modal-content="Ссылки позволяют получить доступ к узлам DOM или элементам React, созданным в методе рендеринга.

        В типичном потоке данных React свойства — это единственный способ, с помощью которого родительские компоненты взаимодействуют со своими дочерними. Чтобы изменить дочерний компонент, вы повторно отображаете его с новыми свойствами. Однако в некоторых случаях вам может потребоваться императивно изменить дочерний компонент вне типичного потока данных. Изменяемый дочерний компонент может быть экземпляром компонента React или элементом DOM. В обоих случаях React предоставляет возможность выхода из ситуации.
        
        ">
                    <i class="fa-solid fa-ghost bg-success px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">Ссылки</h6>
            </header>
        </article>
        <article data-step="13">
            <header class="d-flex align-items-center text-success bg-success bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal" data-modal-content="Обработка событий с помощью элементов React очень похожа на обработку событий с помощью элементов DOM. Есть некоторые различия в синтаксисе:

        События React именуются с использованием camelCase, а не строчными буквами.
        В JSX в качестве обработчика событий передаётся функция, а не строка.          
        ">
                    <i class="fa-solid fa-ghost bg-success px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">События
                </h6>
            </header>
        </article>
        <article data-step="14">
            <header class="d-flex align-items-center text-success bg-success bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal" data-modal-content="Компонент высшего порядка (HOC) — это продвинутый метод в React для повторного использования логики компонентов. HOC не являются частью React API как такового. Это шаблон, который возникает в результате композиционной природы React.

        Если говорить конкретно, то компонент более высокого порядка — это функция, которая принимает компонент и возвращает новый компонент.
        
        Компоненты высшего порядка редко используются в современном коде React. Для повторного использования логики в основном применяются хуки React.
                
        ">
                    <i class="fa-solid fa-ghost bg-success px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">Компоненты высокого порядка
                </h6>
            </header>
        </article>
    </section>

    <!-- Секция Хуки -->
    <section class="step four text-success">
        <div class="circle">
            <h2>Хуки</h2>
        </div>
        <article data-step="15">
            <header class="d-flex align-items-center text-success bg-success bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal" data-modal-content="useEffect Это специальный хук, который позволяет запускать побочные эффекты в React. Он похож на componentDidMount и componentDidUpdate, но запускается только при изменении компонента (или некоторых его свойств) и при первоначальной загрузке.
        ">
                    <i class="fa-solid fa-ghost bg-success px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">useEffect</h6>
            </header>
        </article>
        <article data-step="16">
            <header class="d-flex align-items-center text-success bg-success bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal"
                    data-modal-content="useState Хук используется для управления состоянием компонента в функциональных компонентах. Вызов useState возвращает массив с двумя элементами: текущим значением состояния и функцией для обновления состояния.">
                    <i class="fa-solid fa-ghost bg-success px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">useState</h6>
            </header>
        </article>
        <article data-step="17">
            <header class="d-flex align-items-center text-success bg-success bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal" data-modal-content="Хук useContext позволяет обмениваться данными между компонентами без необходимости передавать свойства через каждый уровень дерева компонентов. Это особенно полезно, когда многим компонентам нужен доступ к одним и тем же данным или когда компоненты глубоко вложены друг в друга.
        ">
                    <i class="fa-solid fa-ghost bg-success px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">useContext</h6>
            </header>
        </article>
        <article data-step="18">
            <header class="d-flex align-items-center text-success bg-success bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal" data-modal-content="useReducer: Альтернатива useState. Принимает редьюсер типа (состояние, действие) => новое состояние и возвращает текущее состояние в сочетании с методом отправки. (Если вы знакомы с Redux, то уже знаете, как это работает.)
        ">
                    <i class="fa-solid fa-ghost bg-success px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">useReducer</h6>
            </header>
        </article>
        <article data-step="19">
            <header class="d-flex align-items-center text-success bg-success bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal" data-modal-content="useCallback Это хук React, который возвращает кэшированную версию функции обратного вызова. Он используется для оптимизации производительности за счёт предотвращения ненужного повторного рендеринга. В частности, он помогает избежать повторного создания функций, если их зависимости не изменились, что может быть полезно при передаче обратных вызовов дочерним компонентам, которые полагаются на ссылочное равенство для предотвращения повторного рендеринга.
        ">
                    <i class="fa-solid fa-ghost bg-success px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">useCallback</h6>
            </header>
        </article>
        <article data-step="20">
            <header class="d-flex align-items-center text-success bg-success bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal" data-modal-content="useMemo Это хук React, который запоминает результат функции. Он используется для оптимизации производительности за счёт кэширования результата функции и возврата кэшированного результата, если входные данные функции не изменились.          
        ">
                    <i class="fa-solid fa-ghost bg-success px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">useMemo</h6>
            </header>
        </article>
        </article>
        <article data-step="21">
            <header class="d-flex align-items-center text-success bg-success bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal" data-modal-content="useRef Это хук React, который позволяет создать изменяемую ссылку, сохраняющуюся при повторном рендеринге компонента. Он хранит значение, которое не вызывает повторный рендеринг при изменении.
        ">
                    <i class="fa-solid fa-ghost bg-success px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">useRef</h6>
            </header>
        </article>
    </section>

    <!-- Секция Операторы сравнения  -->
    <section class="step five text-success">
        <div class="circle">
            <h2>Управление состоянием</h2>
        </div>
        <article data-step="22">
            <header class="d-flex align-items-center text-success bg-success bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal"
                    data-modal-content="Управление состоянием приложения — это процесс сохранения информации о входных данных приложения в нескольких связанных потоках данных, которые образуют полную бизнес-транзакцию или сеанс, чтобы понимать состояние приложения в любой момент времени. В информатике входные данные — это информация, которую пользователь вводит в программу, а состояние — это состояние приложения в соответствии с сохранёнными входными данными, которые хранятся в виде переменных или констант. Состояние также можно описать как совокупность сохранённой информации, которая образует полный сеанс.">
                    <i class="fa-solid fa-ghost bg-success px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">Что это?</h6>
            </header>
        </article>
        <article data-step="23">
            <header class="d-flex align-items-center text-success bg-success bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal"
                    data-modal-content="Jotai использует атомарный подход к глобальному управлению состоянием React.

        Создавайте состояние, комбинируя атомы, и автоматически оптимизируйте рендеринг на основе зависимостей атомов. Это решает проблему дополнительного рендеринга в контексте React, устраняет необходимость в мемоизации и обеспечивает аналогичный сигнальным функциям интерфейс разработчика, сохраняя при этом модель декларативного программирования.
        
        Он может использоваться как для простой замены useState, так и для корпоративного приложения TypeScript со сложными требованиями. Кроме того, существует множество утилит и расширений, которые помогут вам в работе!">
                    <i class="fa-solid fa-ghost bg-success px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">Jotai</h6>
            </header>
        </article>
        <article data-step="24">
            <header class="d-flex align-items-center text-success bg-success bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal"
                    data-modal-content="Zustand — это небольшое, быстрое и масштабируемое решение для управления состоянием на основе упрощённых принципов потока данных. У него удобный API на основе хуков, он не перегружен шаблонами и не навязывается.

        Zustand часто используется в качестве альтернативы другим библиотекам управления состоянием, таким как Redux и MobX, из-за своей простоты и небольшого размера. Он особенно хорошо подходит для небольших и средних приложений, где не требуется сложность более крупных библиотек управления состоянием.">
                    <i class="fa-solid fa-ghost bg-success px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">Zustand</h6>
            </header>
        </article>
        <article data-step="25">
            <header class="d-flex align-items-center text-success bg-success bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal"
                    data-modal-content="Контекст позволяет передавать данные по дереву компонентов без необходимости вручную передавать свойства на каждом уровне.

        В типичном приложении React данные передаются сверху вниз (от родителя к дочернему компоненту) с помощью пропсов, но такое использование может быть неудобным для определённых типов пропсов (например, настроек локали, темы пользовательского интерфейса), которые требуются многим компонентам в приложении. Контекст позволяет обмениваться такими значениями между компонентами без необходимости явно передавать пропсы через каждый уровень дерева.">
                    <i class="fa-solid fa-ghost bg-success px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">Context
                </h6>
            </header>
        </article>
        <article data-step="26">
            <header class="d-flex align-items-center text-success bg-success bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal"
                    data-modal-content="MobX — это мощная и интуитивно понятная библиотека для управления состоянием, которая повышает масштабируемость и простоту приложений за счёт использования функционального реактивного программирования. Основная философия MobX заключается в простоте и эффективности. Разработчики могут писать лаконичный код без шаблонов, который чётко выражает их намерения. Например, обновить поле записи так же просто, как выполнить стандартное присваивание в JavaScript, при этом MobX автоматически обнаруживает изменения и распространяет их по всему приложению. Это устраняет необходимость в специализированных инструментах для асинхронных процессов обработки данных.">
                    <i class="fa-solid fa-ghost bg-success px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">MobX</h6>
            </header>
        </article>
    </section>

    <!-- 10. Классы ES6 -->
    <section class="step six text-primary">
        <div class="circle">
            <h2>Написание CSS</h2>
        </div>
        <article data-step="27">
            <header class="d-flex align-items-center text-primary bg-primary bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal"
                    data-modal-content="
        CSS-фреймворк, предоставляющий атомарные CSS-классы, которые помогут вам стилизовать компоненты, например, flex, pt-4, text-center и rotate-90, которые можно комбинировать для создания любого дизайна непосредственно в вашей разметке.">
                    <i class="fa-solid fa-box-open bg-primary px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">Tailwind CSS
                </h6>
            </header>
        </article>
        <article data-step="28">
            <header class="d-flex align-items-center text-primary bg-primary bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal" data-modal-content="
        Файлы CSS, в которых все имена классов и анимаций по умолчанию имеют локальную область видимости.

        ">
                    <i class="fa-solid fa-project-diagram bg-primary px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">Модули CSS
                </h6>
            </header>
        </article>
        <article data-step="29">
            <header class="d-flex align-items-center text-primary bg-primary bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal" data-modal-content="
        Panda CSS — это CSS-in-JS с генерацией стилей во время сборки, совместимый с RSC, поддерживающий несколько вариантов и предоставляющий разработчикам лучшие в своём классе возможности.

        ">
                    <i class="fa-solid fa-graduation-cap bg-primary px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">Panda CSS
                </h6>
            </header>
        </article>
    </section>
    <!-- Секция Модули (ESModules) -->
    <section class="step seven text-success">
        <div class="circle">
            <h2>Вызовы API
            </h2>
        </div>
        <article data-step="30">
            <header class="d-flex align-items-center text-primary bg-primary bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal" data-modal-content="
        Apollo — это платформа для создания единого графа, уровня связи, который помогает управлять потоком данных между клиентами приложений (например, веб-приложениями и нативными приложениями) и серверными службами.

        ">
                    <i class="fa-solid fa-layer-group bg-primary px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">Apollo</h6>
            </header>
        </article>
        <article data-step="31">
            <header class="d-flex align-items-center text-primary bg-primary bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal"
                    data-modal-content="
        Мощное асинхронное управление состоянием, утилиты для работы с серверным состоянием и получение данных для TS/JS, React, Solid, Svelte и Vue.">
                    <i class="fa-solid fa-puzzle-piece bg-primary px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">React запрос
                </h6>
            </header>
        </article>
        <article data-step="32">
            <header class="d-flex align-items-center text-primary bg-primary bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal"
                    data-modal-content="
        Relay — это клиент JavaScript, используемый в браузере для получения данных GraphQL. Это фреймворк JavaScript, разработанный Facebook для управления данными и их получения в приложениях React. Он создан с учётом масштабируемости для работы со сложными приложениями, такими как Facebook. Конечная цель GraphQL и Relay — обеспечить мгновенное взаимодействие с пользовательским интерфейсом.">
                    <i class="fa-solid fa-exchange-alt bg-primary px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">Relay</h6>
            </header>
        </article>
        <article data-step="33">
            <header class="d-flex align-items-center text-primary bg-primary bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal"
                    data-modal-content="
        urql (Universal React Query Library) — это библиотека для управления данными GraphQL в приложениях React. Она разработана и поддерживается компанией Formidable Labs и доступна как программное обеспечение с открытым исходным кодом.

urql — это простой в использовании и гибкий инструмент с простым API для выполнения запросов и мутаций GraphQL. Он основан на концепции клиента, который используется для управления данными GraphQL в приложении. Клиент предоставляет набор утилит и API для управления данными GraphQL, в том числе:

ExecuteQuery: утилита для выполнения запроса GraphQL.
executeMutation: утилита для выполнения мутации GraphQL.
useQuery: хук для выполнения запроса GraphQL и получения результата в компоненте.
useMutation: хук для выполнения мутации GraphQL и получения результата в компоненте.
urql часто используется в качестве альтернативы другим библиотекам GraphQL, таким как Apollo Client, из-за своей простоты и небольшого размера. Он особенно хорошо подходит для небольших и средних приложений React, где не требуется сложность других библиотек GraphQL.">
                    <i class="fa-solid fa-puzzle-piece bg-primary px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">urql</h6>
            </header>
        </article>
        <article data-step="34">
            <header class="d-flex align-items-center text-primary bg-primary bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal" data-modal-content="
        Наиболее распространённым способом взаимодействия интерфейсных программ с серверами является протокол HTTP. Вы, вероятно, знакомы с Fetch API и интерфейсом XMLHttpRequest, которые позволяют получать ресурсы и отправлять HTTP-запросы.

Axios — это клиентский HTTP-интерфейс, основанный на интерфейсе XMLHttpRequest, предоставляемом браузерами.
        ">
                    <i class="fa-solid fa-exchange-alt bg-primary px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">Axios</h6>
            </header>
        </article>
        <article data-step="35">
            <header class="d-flex align-items-center text-primary bg-primary bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal" data-modal-content="
        RTK Query — это инструмент для получения и кэширования данных, который входит в состав пакета Redux Toolkit. Он предназначен для упрощения распространённых сценариев получения данных, включая кэширование, опрос и аннулирование.
        ">
                    <i class="fa-solid fa-exchange-alt bg-primary px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">rtk-запрос
                </h6>
            </header>
        </article>
        <article data-step="36">
            <header class="d-flex align-items-center text-primary bg-primary bg-opacity-10">
                <span class="info-btn" data-bs-toggle="modal" data-bs-target="#infoModal" data-modal-content="
        SWR - это библиотека React Hooks для выборки данных.

Название «SWR» происходит от «stale-while-revalidate» — стратегии аннулирования кэша, популяризированной в HTTP RFC 5861. SWR сначала возвращает данные из кэша (устаревшие), затем отправляет запрос (на аннулирование) и, наконец, снова возвращает актуальные данные.

С помощью всего одного хука вы можете значительно упростить логику получения данных в своём проекте.
        ">
                    <i class="fa-solid fa-exchange-alt bg-primary px-3"></i>
                </span>
                <h6 class="text-uppercase my-3 ps-4">SWR</h6>
            </header>
        </article>
    </section>
</main>
{% endblock content %}
